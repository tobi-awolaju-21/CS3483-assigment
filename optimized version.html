<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="./p5.js"></script>
  <script src="./ml5.min.js"></script>
  <title>ml5.js Handpose Example</title>
</head>

<body>

  <script>
    let img1, img2;
    let prevX, prevY;
    var mouseXi, mouseYi = 0;
    let circleColor = 255;
    let fPressed = false;
    let video; // Variable to hold the webcam video stream
    let handpose; // Handpose model
    let predictions = [];
    let regionMode = false;
    let boundingBox = { x: 0, y: 0, width: 0, height: 0 };
    let sX, sY; // Inde finger
    let eX, eY; // thumb
    let copiedImage;
    let paste = 0;
    //copying destination
    let cx1, cx2, cy1, cy2;
    //pasting destination
    let vx1, vx2;

    let selecting = false;
    let selection = { x: 0, y: 0, w: 0, h: 0 };
    let clipboard;
    let pasteBuffer;





    function preload() {
      // Load the actual image
      img = loadImage('image.jpg');
    }

    function setup() {
      createCanvas(1000, 500);
      canvas2 = createGraphics(1000, 500);
      canvas3 = createGraphics(1000, 500);
      img.resize(500, 500);


      // Create a video capture object and start the stream
      video = createCapture(VIDEO);
      video.size(500, 500);
      video.hide(); // Hide the video element

      // Load the Handpose model
      handpose = ml5.handpose(video, modelReady);

      // Listen for predictions
      handpose.on('predict', gotPredictions);


      // setup buffer to paste into
      pasteBuffer = createGraphics(width, height);
    }


    function modelReady() {
      console.log('Handpose model loaded.');
    }

    function gotPredictions(results) {
      predictions = results;
    }






    function draw() {
      background(0);
      // Set background to clear previous frames
      image(canvas2, 0, 0);
      // Draw images on the background
      canvas2.image(img, 0, 0);
      // render pasted graphics
      canvas2.image(pasteBuffer, 0, 0);
     
      // start of bound box and copy algorithm
      if (regionMode) {
        selection.w = eX - selection.x;
        selection.h = eY - selection.y;
        // Draw the rectangle to show selectin bound
        noFill();
        stroke(250);
        rect(selection.x, selection.y, selection.w, selection.h);
        //end of boundbox
      } else {
      }

      // Display the live webcam preview
      // Flip the video horizontally
      push();
      translate(width, 0);
      scale(-1, 1);
      image(video, 0, 0, 500, 500);
      pop();
      //rest


      // Draw a green dot following the index finger
      if (predictions.length > 0) {
        let indexFinger = predictions[0].landmarks[8]; // Index finger tip
        let thumb = predictions[0].landmarks[4]; // Thumb tip


        fill(250); // Green color
        noStroke(); // No outline
        // Apply the same transformation to the hand landmarks
        let flippedIndexFinger = [(width - indexFinger[0]), indexFinger[1]];
        ellipse(flippedIndexFinger[0], flippedIndexFinger[1], 20, 20);


        // Draw a red dot for the thumb
        fill(250); // Red color
        let flippedThumb = [(width - thumb[0]), thumb[1]];
        ellipse(flippedThumb[0], flippedThumb[1], 10, 10);


        sX = mouseXi - 500; // index finger x
        sY = mouseYi; // index finger y
        eX = flippedThumb[0]; // thumb x
        eY = flippedThumb[1]; // thumb y

        selection.x = sX - 500;
        selection.Y = sY;
        //end of Draw the green dot
        mouseXi = flippedIndexFinger[0] + 500;
        mouseYi = flippedIndexFinger[1];
      }

      // Start of pointers
      fill(255, 50); // Set fill color to blue
      noStroke(); // No outline
      // Left pointer
      ellipse(mouseXi - 1000, mouseYi, 50, 50);
      // Right pointer
      // ellipse(mouseXi - 500, mouseYi, 50, 50);
      // End of pointers

      // Free draw mode start
      if (fPressed) {
        circleColor = 255;
        let x = 500 * (mouseXi - 500) / 500;
        canvas3.stroke(circleColor);
        canvas3.strokeWeight(5);
        canvas3.fill(250);
        canvas3.line(prevX - 1000, prevY, mouseXi - 1000, mouseYi);

      }
      // Free draw mode ends




      // Code that re-displays  canvas3 to keep the free form line
      image(canvas3, 0, 0);

      // Update the previous position
      prevX = mouseXi;
      prevY = mouseYi;


      if (paste > 0 && paste < 2) {
        canvas3.fill(250, 50, 250);
        canvas3.stroke(250, 50);
        canvas3.rect(mouseXi - 500, mouseYi, 100, 100);
        paste = 2;
      }








    }



    function keyPressed(keyEvent) {
      if (key == 'c') {
        console.log("copy image", selection);
        // use get() to "clone" a subsection of the main image
        clipboard = img.get(selection.x, selection.y, selection.w, selection.h);
        regionMode = false;
      }

      if (key == 'v') {
        console.log("paste image");
        console.log("mouseX" + mouseX + "sX" + sX);
        if (clipboard) {
          // simply render the clipboard image 
          pasteBuffer.image(clipboard, sX - 500, sY);

        }
      }
    }




    // Toggle free form mode
    document.addEventListener('keydown', function (event) {
      if (event.keyCode === 70) {
        console.log(fPressed);
        fPressed = true; // Toggle the value
      }
    });

    // Clear drawing
    document.addEventListener('keydown', function (event) {
      if (event.key === 'e' || event.key === 'E') {
        fPressed = false;
        regionMode = false;
        canvas3.clear();
        console.log("exited all modes");
      }
    });


    // Selection mode 
    document.addEventListener('keydown', function (event) {
      if (event.key === 's' || event.key === 'S') {
        regionMode = true;
        console.log("region selection and copyng mode")
      }
    });

  </script>
</body>

</html>